<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Knoxera</title>
  <link rel="icon" type="image/png" href="knoxeralogo.png" />

  <meta property="og:title" content="Knoxera" />
  <meta property="og:image" content="https://knoxera.site/knoxeralogo.png" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />

  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: black;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Размеры канваса — под размер окна
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    const tileSize = 60;

    // Чанки с разными структурами, чтобы не повторялись полностью окружены стенами
    const chunks = [
      [
        [1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,0,1],
        [1,0,1,0,0,1,0,1],
        [1,0,1,0,0,1,0,1],
        [1,0,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1],
      ],
      [
        [1,1,1,1,1,1,1,1],
        [1,0,0,1,0,0,0,1],
        [1,0,0,1,0,1,0,1],
        [1,0,0,1,0,1,0,1],
        [1,0,0,0,0,1,0,1],
        [1,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1],
      ],
      [
        [1,1,1,1,1,1,1,1],
        [1,0,0,0,0,1,0,1],
        [1,0,1,1,0,1,0,1],
        [1,0,1,0,0,0,0,1],
        [1,0,1,0,1,1,1,1],
        [1,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,0,1],
        [1,1,1,1,1,1,1,1],
      ],
      [
        [1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,1],
        [1,1,1,1,1,0,1,1],
        [1,0,0,0,1,0,0,1],
        [1,0,1,0,0,0,0,1],
        [1,0,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1],
      ]
    ];

    // Карта чанков — бесконечная в теории
    // Для генерации — используем случайный выбор чанка по координатам
    function getChunk(cx, cy) {
      // Простое хеширование координат для стабильного выбора чанка
      let idx = Math.abs((cx * 31 + cy * 17)) % chunks.length;
      return chunks[idx];
    }

    // Игрок в мировых координатах (пиксели)
    const player = {
      x: tileSize * 4 + tileSize/2,
      y: tileSize * 4 + tileSize/2,
      radius: tileSize / 4,
      speed: 3
    };

    const keys = { w:false, a:false, s:false, d:false };

    // Проверка коллизии круга и квадрата (стена)
    function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
      const nearestX = Math.max(rx, Math.min(cx, rx + rw));
      const nearestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - nearestX;
      const dy = cy - nearestY;
      return (dx * dx + dy * dy) < (radius * radius);
    }

    // Проверка коллизий с текущим положением игрока
    function canMoveTo(x, y) {
      // Определяем, в каком чанке находится точка
      const chunkX = Math.floor(x / (tileSize * 8));
      const chunkY = Math.floor(y / (tileSize * 8));
      const localX = x - chunkX * tileSize * 8;
      const localY = y - chunkY * tileSize * 8;

      const chunk = getChunk(chunkX, chunkY);

      // Проверяем коллизии по стенам чанка
      for(let yy=0; yy < chunk.length; yy++) {
        for(let xx=0; xx < chunk[yy].length; xx++) {
          if(chunk[yy][xx] === 1) {
            if(circleRectCollision(
              x, y, player.radius,
              chunkX * tileSize * 8 + xx * tileSize,
              chunkY * tileSize * 8 + yy * tileSize,
              tileSize, tileSize)) {
              return false;
            }
          }
        }
      }
      return true;
    }

    // Рисуем карту вокруг игрока (3x3 чанка)
    function drawMap() {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round'; // чтобы углы были гладкими

      // Центрируем камеру на игроке
      const camX = player.x - canvas.width / 2;
      const camY = player.y - canvas.height / 2;

      // Рисуем 3x3 чанка вокруг игрока
      for(let cy = -1; cy <= 1; cy++) {
        for(let cx = -1; cx <=1; cx++) {
          const chunk = getChunk(
            Math.floor(player.x / (tileSize * 8)) + cx,
            Math.floor(player.y / (tileSize * 8)) + cy
          );
          const offsetX = (Math.floor(player.x / (tileSize * 8)) + cx) * tileSize * 8 - camX;
          const offsetY = (Math.floor(player.y / (tileSize * 8)) + cy) * tileSize * 8 - camY;

          // Рисуем только внешнюю обводку чанка без внутренних линий
          // Для этого строим контур по стенам чанка
          // Найдем внешние линии по соседям
          ctx.beginPath();

          for(let y=0; y<chunk.length; y++) {
            for(let x=0; x<chunk[y].length; x++) {
              if(chunk[y][x] === 1) {
                // Проверяем каждую сторону, если сосед пустой или вне чанка, рисуем линию
                const px = offsetX + x * tileSize;
                const py = offsetY + y * tileSize;

                // Верх
                if(y === 0 || chunk[y-1][x] === 0) {
                  ctx.moveTo(px, py);
                  ctx.lineTo(px + tileSize, py);
                }
                // Низ
                if(y === chunk.length-1 || chunk[y+1][x] === 0) {
                  ctx.moveTo(px, py + tileSize);
                  ctx.lineTo(px + tileSize, py + tileSize);
                }
                // Лево
                if(x === 0 || chunk[y][x-1] === 0) {
                  ctx.moveTo(px, py);
                  ctx.lineTo(px, py + tileSize);
                }
                // Право
                if(x === chunk[y].length-1 || chunk[y][x+1] === 0) {
                  ctx.moveTo(px + tileSize, py);
                  ctx.lineTo(px + tileSize, py + tileSize);
                }
              }
            }
          }
          ctx.stroke();
        }
      }
    }

    function drawPlayer() {
      const camX = player.x - canvas.width / 2;
      const camY = player.y - canvas.height / 2;

      ctx.fillStyle = '#4cc9f0';
      ctx.beginPath();
      ctx.arc(player.x - camX, player.y - camY, player.radius, 0, Math.PI * 2);
      ctx.fill();
    }

    function update() {
      let nextX = player.x;
      let nextY = player.y;

      if (keys.w) nextY -= player.speed;
      if (keys.s) nextY += player.speed;
      if (keys.a) nextX -= player.speed;
      if (keys.d) nextX += player.speed;

      // Скользящее движение: двигаемся по X и Y отдельно
      if (canMoveTo(nextX, player.y)) {
        player.x = nextX;
      }
      if (canMoveTo(player.x, nextY)) {
        player.y = nextY;
      }
    }

    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener('keyup', e => {
      if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false;
    });

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      drawPlayer();
      update();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
