<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Knoxera — Demo</title>
  <link rel="icon" href="knoxeralogo.png" />
  <style>
    :root{--accent:#4cc9f0}
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
    /* Menu overlay */
    #menu {
      position:fixed;inset:0;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      z-index:20;pointer-events:auto;
      background:rgba(0,0,0,0.85);
    }
    #particles { position:fixed; inset:0; z-index:10; pointer-events:none; }
    .tabs { display:flex; gap:12px; margin-bottom:18px; z-index:22 }
    .tab { padding:8px 16px; cursor:pointer; color:var(--accent); font-weight:700; border-bottom:2px solid transparent; user-select:none }
    .tab.active { border-bottom-color:var(--accent) }
    form { width:320px; background:#111; padding:20px 24px; border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,0.6); display:flex; flex-direction:column; gap:12px; z-index:22 }
    label{ font-size:13px; color:#ddd }
    input{ padding:10px; border-radius:6px; border:1px solid #444; background:#222; color:#fff; outline:none }
    input:focus{ border-color:#777; background:#2a2a2a }
    button{ padding:10px; border-radius:6px; border:2px solid #fff; background:#000; color:#fff; font-weight:700; cursor:pointer }
    button:disabled{ opacity:.45; cursor:not-allowed }
    #header{ display:none; align-items:center; gap:10px; padding:8px 12px; color:var(--accent); font-weight:700; z-index:15 }
    #header img{ width:40px; height:40px; border-radius:50% }
    canvas#game{ display:block; background:#000; border:1px solid rgba(255,255,255,0.06); width:100vw; height:calc(100vh - 90px); box-sizing:border-box }
    #counter{ position:fixed; top:10px; right:20px; display:flex; align-items:center; gap:8px; color:var(--accent); font-weight:700; z-index:15 }
    #counter img{ width:28px; height:28px; image-rendering:pixelated }
    #controls { position:fixed; left:10px; bottom:10px; z-index:15; color:#aaa; font-size:13px }
    .notice { color:#f66; font-size:13px; text-align:center }
  </style>
</head>
<body>

  <!-- MENU -->
  <div id="menu">
    <canvas id="particles"></canvas>

    <div class="tabs">
      <div id="tab-login" class="tab active">Login</div>
      <div id="tab-register" class="tab">Register</div>
    </div>

    <!-- LOGIN FORM -->
    <form id="login-form" style="display:flex">
      <label for="login-email">Email</label>
      <input id="login-email" type="email" placeholder="email@example.com" autocomplete="username" required />

      <label for="login-password">Password</label>
      <input id="login-password" type="password" placeholder="password" autocomplete="current-password" minlength="6" required />

      <button id="login-btn" type="submit" disabled>Login</button>
      <div id="login-msg" class="notice" style="height:18px"></div>
    </form>

    <!-- REGISTER FORM -->
    <form id="register-form" style="display:none">
      <label for="reg-email">Email</label>
      <input id="reg-email" type="email" placeholder="email@example.com" required />

      <label for="reg-password">Password (min 6 chars)</label>
      <input id="reg-password" type="password" placeholder="password" minlength="6" required />

      <label for="reg-nick">Nickname</label>
      <input id="reg-nick" type="text" placeholder="Your nickname" maxlength="20" required />

      <button id="reg-btn" type="submit" disabled>Register</button>
      <div id="reg-msg" class="notice" style="height:18px"></div>
    </form>
  </div>

  <!-- Header (after login) -->
  <div id="header">
    <img src="knoxeralogo.png" alt="logo" />
    <div id="header-title">Knoxera</div>
    <div style="margin-left:12px; color:#ccc; font-weight:600" id="player-nick"></div>
    <button id="logout-btn" style="margin-left:12px; padding:6px 10px; border-radius:6px; background:#111; border:1px solid #333; color:#fff; cursor:pointer">Logout</button>
  </div>

  <!-- Game canvas -->
  <canvas id="game"></canvas>

  <!-- Counter -->
  <div id="counter" style="display:none">
    <img src="greencristal.png" alt="crystal"/>
    <div id="crystal-count">0</div>
  </div>

  <div id="controls">WASD / Arrow keys to move</div>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script>
  /******************************************************************
   *  CONFIG: вставлен твой firebaseConfig (как ты просил)
   ******************************************************************/
  const firebaseConfig = {
    apiKey: "AIzaSyD6kjiQCEjtI537KqmEN34NxOZ6BBIbC2c",
    authDomain: "knoxera.firebaseapp.com",
    projectId: "knoxera",
    storageBucket: "knoxera.firebasestorage.app",
    messagingSenderId: "207649077497",
    appId: "1:207649077497:web:01e865716c790acf798a28",
    measurementId: "G-913NRJWC1Z"
  };

  // Инициализация Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  // Быстрый helper для вывода ошибок
  function showError(msg, domId){
    if(domId){
      const el = document.getElementById(domId);
      if(el) el.textContent = msg;
    } else {
      alert(msg);
    }
  }

  /******************************************************************
   *  MENU / AUTH UI logic
   ******************************************************************/
  const tabLogin = document.getElementById('tab-login');
  const tabRegister = document.getElementById('tab-register');
  const loginForm = document.getElementById('login-form');
  const registerForm = document.getElementById('register-form');

  tabLogin.onclick = () => { tabLogin.classList.add('active'); tabRegister.classList.remove('active'); loginForm.style.display='flex'; registerForm.style.display='none'; }
  tabRegister.onclick = () => { tabRegister.classList.add('active'); tabLogin.classList.remove('active'); registerForm.style.display='flex'; loginForm.style.display='none'; }

  // Elements
  const loginEmail = document.getElementById('login-email');
  const loginPassword = document.getElementById('login-password');
  const loginBtn = document.getElementById('login-btn');
  const loginMsg = document.getElementById('login-msg');

  const regEmail = document.getElementById('reg-email');
  const regPassword = document.getElementById('reg-password');
  const regNick = document.getElementById('reg-nick');
  const regBtn = document.getElementById('reg-btn');
  const regMsg = document.getElementById('reg-msg');

  const header = document.getElementById('header');
  const headerTitle = document.getElementById('header-title');
  const playerNickEl = document.getElementById('player-nick');
  const logoutBtn = document.getElementById('logout-btn');

  const menu = document.getElementById('menu');
  const gameCanvas = document.getElementById('game');
  const crystalCountEl = document.getElementById('crystal-count');
  const counterEl = document.getElementById('counter');

  // Enable/disable buttons based on validity
  function validateLoginBtn(){ loginBtn.disabled = !(loginEmail.checkValidity() && loginPassword.value.trim().length >= 6); }
  function validateRegBtn(){ regBtn.disabled = !(regEmail.checkValidity() && regPassword.value.trim().length >= 6 && regNick.value.trim().length >= 2); }

  [loginEmail, loginPassword].forEach(i=>i.addEventListener('input', validateLoginBtn));
  [regEmail, regPassword, regNick].forEach(i=>i.addEventListener('input', validateRegBtn));

  // Register handler
  regFormHandler = async (e) => {
    e.preventDefault();
    regMsg.textContent = '';
    regBtn.disabled = true;
    try {
      const email = regEmail.value.trim();
      const pass = regPassword.value;
      const nick = regNick.value.trim();

      const userCredential = await auth.createUserWithEmailAndPassword(email, pass);
      const user = userCredential.user;
      // create user doc
      await db.collection('users').doc(user.uid).set({
        nickname: nick,
        crystals: 0,
        collected: [] // list of collected crystal IDs
      });
      // update displayName
      await user.updateProfile({ displayName: nick });
      // Success: UI will switch by onAuthStateChanged listener
    } catch(err) {
      regMsg.textContent = err.message;
    } finally {
      regBtn.disabled = false;
    }
  };
  registerForm.addEventListener('submit', regFormHandler);

  // Login handler
  loginFormHandler = async (e) => {
    e.preventDefault();
    loginMsg.textContent = '';
    loginBtn.disabled = true;
    try {
      await auth.signInWithEmailAndPassword(loginEmail.value.trim(), loginPassword.value);
      // onAuthStateChanged handles UI
    } catch(err) {
      loginMsg.textContent = err.message;
    } finally {
      loginBtn.disabled = false;
    }
  };
  loginForm.addEventListener('submit', loginFormHandler);

  // Logout
  logoutBtn.addEventListener('click', async () => {
    await auth.signOut();
  });

  /******************************************************************
   *  PARTICLES (menu background) — белые шарики
   ******************************************************************/
  const partCanvas = document.getElementById('particles');
  const pctx = partCanvas.getContext('2d');
  let pw, ph;
  function resizeParticles(){
    pw = window.innerWidth;
    ph = window.innerHeight;
    partCanvas.width = pw;
    partCanvas.height = ph;
  }
  window.addEventListener('resize', resizeParticles);
  resizeParticles();

  class Particle {
    constructor(){
      this.reset();
    }
    reset(){
      this.x = Math.random()*pw;
      this.y = Math.random()*ph;
      this.r = 1 + Math.random()*3;
      this.vx = (Math.random()-0.5)*0.6;
      this.vy = -(0.2 + Math.random()*0.8);
      this.alpha = 0.15 + Math.random()*0.6;
    }
    step(){
      this.x += this.vx;
      this.y += this.vy;
      if(this.y < -10 || this.x < -20 || this.x > pw+20) this.reset(), this.y = ph+10;
    }
    draw(){
      pctx.beginPath();
      pctx.fillStyle = `rgba(255,255,255,${this.alpha})`;
      pctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      pctx.fill();
    }
  }
  const particles = [];
  for(let i=0;i<80;i++) particles.push(new Particle());
  function animateParticles(){
    pctx.clearRect(0,0,pw,ph);
    for(const p of particles){ p.step(); p.draw(); }
    requestAnimationFrame(animateParticles);
  }
  animateParticles();

  /******************************************************************
   *  FIRESTORE: Helpers to create/load user document
   ******************************************************************/
  async function ensureUserDoc(uid, displayName){
    const ref = db.collection('users').doc(uid);
    const snap = await ref.get();
    if(!snap.exists){
      await ref.set({ nickname: displayName || 'Player', crystals: 0, collected: [] });
      return { nickname: displayName || 'Player', crystals: 0, collected: [] };
    }
    return snap.data();
  }

  // Utility: deterministic RNG (LCG) seeded by string (user.uid)
  function createPRNG(seedString){
    // simple hash to int
    let h = 2166136261 >>> 0;
    for(let i=0;i<seedString.length;i++){
      h ^= seedString.charCodeAt(i);
      h = Math.imul(h, 16777619) >>> 0;
    }
    let state = h;
    return function(){
      // LCG params
      state = (state * 1664525 + 1013904223) >>> 0;
      return state / 0x100000000;
    };
  }

  /******************************************************************
   *  GAME: deterministic crystal positions + persistence of collected
   ******************************************************************/
  const game = {
    tileSize: 32,
    worldW: 80,  // tiles
    worldH: 50,  // tiles
    crystalsCount: 120
  };

  let currentUser = null;
  let userCollectedSet = new Set(); // set of collected crystal ids
  let crystalsMap = new Map(); // id -> {xTile, yTile}
  let crystalsCollected = 0;

  // create deterministic crystals for a given UID
  function genCrystalsForUser(uid){
    crystalsMap.clear();
    const rng = createPRNG(uid);
    for(let i=0;i<game.crystalsCount;i++){
      // generate tile coordinates within world, avoid edges
      const x = Math.floor(rng() * (game.worldW - 4)) + 2;
      const y = Math.floor(rng() * (game.worldH - 4)) + 2;
      crystalsMap.set(String(i), { xTile: x, yTile: y });
    }
  }

  // load user data from Firestore and prepare game state
  async function loadUserDataAndStart(user){
    try {
      const docRef = db.collection('users').doc(user.uid);
      const doc = await docRef.get();
      let data;
      if(!doc.exists){
        data = { nickname: user.displayName || 'Player', crystals: 0, collected: [] };
        await docRef.set(data);
      } else {
        data = doc.data();
      }
      // prepare crystals
      genCrystalsForUser(user.uid);
      userCollectedSet = new Set(Array.isArray(data.collected) ? data.collected : []);
      crystalsCollected = data.crystals || 0;
      crystalCountEl.textContent = crystalsCollected;
      // update header
      document.getElementById('player-nick').textContent = data.nickname || user.displayName || 'Player';
      // show UI
      menu.style.display = 'none';
      header.style.display = 'flex';
      gameCanvas.style.display = 'block';
      counterEl.style.display = 'flex';
      // set canvas size and start game loop
      resizeGameCanvas();
      if(!gameLoopRunning){
        gameLoopRunning = true;
        requestAnimationFrame(loop);
      }
    } catch (err) {
      showError('Load user data failed: ' + err.message);
    }
  }

  // on auth state changed
  auth.onAuthStateChanged(async (user) => {
    if(user){
      currentUser = user;
      await loadUserDataAndStart(user);
    } else {
      currentUser = null;
      // show menu
      menu.style.display = 'flex';
      header.style.display = 'none';
      gameCanvas.style.display = 'none';
      counterEl.style.display = 'none';
      // clear game state
      userCollectedSet = new Set();
      crystalsMap.clear();
      crystalsCollected = 0;
      crystalCountEl.textContent = '0';
    }
  });

  // Register/ Login fields pre-validation done above

  /******************************************************************
   *  GAME RENDER & LOGIC
   ******************************************************************/
  const gc = gameCanvas.getContext('2d');
  let gw, gh;
  function resizeGameCanvas(){
    gw = window.innerWidth;
    gh = window.innerHeight - 90;
    gameCanvas.width = gw;
    gameCanvas.height = gh;
  }
  window.addEventListener('resize', resizeGameCanvas);

  let player = { x: 0, y: 0, radius: 12, speed: 3.5, color: '#4cc9f0' };
  // place player roughly center of world tiles
  function resetPlayerPosition(){
    player.x = (game.worldW * game.tileSize) / 2;
    player.y = (game.worldH * game.tileSize) / 2;
  }
  resetPlayerPosition();

  // keyboard
  const pressed = {};
  window.addEventListener('keydown', e => { pressed[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', e => { pressed[e.key.toLowerCase()] = false; });

  // camera center on player
  function worldToScreen(wx, wy, camX, camY){
    return { sx: Math.round(wx - camX), sy: Math.round(wy - camY) };
  }

  // game loop
  let gameLoopRunning = false;
  function loop(){
    // update
    let dx = 0, dy = 0;
    if(pressed['w'] || pressed['arrowup']) dy -= player.speed;
    if(pressed['s'] || pressed['arrowdown']) dy += player.speed;
    if(pressed['a'] || pressed['arrowleft']) dx -= player.speed;
    if(pressed['d'] || pressed['arrowright']) dx += player.speed;
    // move player with simple bounds
    const maxX = game.worldW * game.tileSize;
    const maxY = game.worldH * game.tileSize;
    player.x = Math.max(player.radius, Math.min(maxX - player.radius, player.x + dx));
    player.y = Math.max(player.radius, Math.min(maxY - player.radius, player.y + dy));

    // camera centered on player
    const camX = player.x - gw/2;
    const camY = player.y - gh/2;

    // draw background
    gc.fillStyle = '#000';
    gc.fillRect(0,0,gw,gh);

    // draw grid lightly for reference
    gc.strokeStyle = 'rgba(255,255,255,0.03)';
    gc.lineWidth = 1;
    for(let tx = 0; tx <= game.worldW; tx+=2){
      const sx = tx * game.tileSize - camX;
      gc.beginPath(); gc.moveTo(sx,0); gc.lineTo(sx,gh); gc.stroke();
    }
    for(let ty = 0; ty <= game.worldH; ty+=2){
      const sy = ty * game.tileSize - camY;
      gc.beginPath(); gc.moveTo(0,sy); gc.lineTo(gw,sy); gc.stroke();
    }

    // draw crystals
    for(const [id, pos] of crystalsMap){
      if(userCollectedSet.has(id)) continue; // already collected
      const wx = pos.xTile * game.tileSize + game.tileSize/2;
      const wy = pos.yTile * game.tileSize + game.tileSize/2;
      const { sx, sy } = worldToScreen(wx, wy, camX, camY);
      // cull if outside screen
      if(sx < -50 || sy < -50 || sx > gw+50 || sy > gh+50) continue;
      // draw crystal (bigger)
      gc.fillStyle = '#2de33b';
      gc.beginPath();
      gc.moveTo(sx, sy - 12);
      gc.lineTo(sx + 10, sy);
      gc.lineTo(sx, sy + 12);
      gc.lineTo(sx - 10, sy);
      gc.closePath();
      gc.fill();
      gc.strokeStyle = 'rgba(255,255,255,0.5)';
      gc.lineWidth = 1.5;
      gc.stroke();
    }

    // draw player
    const pScreen = worldToScreen(player.x, player.y, camX, camY);
    gc.fillStyle = player.color;
    gc.beginPath();
    gc.arc(pScreen.sx, pScreen.sy, player.radius, 0, Math.PI*2);
    gc.fill();

    // check pickups (distance)
    for(const [id, pos] of crystalsMap){
      if(userCollectedSet.has(id)) continue;
      const wx = pos.xTile * game.tileSize + game.tileSize/2;
      const wy = pos.yTile * game.tileSize + game.tileSize/2;
      const dist = Math.hypot(player.x - wx, player.y - wy);
      if(dist < player.radius + 10){
        // collect
        userCollectedSet.add(id);
        crystalsCollected++;
        crystalCountEl.textContent = crystalsCollected;
        // persist to Firestore: increment crystals and add id to collected array
        if(currentUser){
          const userRef = db.collection('users').doc(currentUser.uid);
          userRef.update({
            crystals: firebase.firestore.FieldValue.increment(1),
            collected: firebase.firestore.FieldValue.arrayUnion(id)
          }).catch(err => {
            console.error('Failed to update user collect:', err);
          });
        }
      }
    }

    if(gameLoopRunning) requestAnimationFrame(loop);
  }

  /******************************************************************
   *  Start/Stop helpers
   ******************************************************************/
  function startLocalGame(){
    resetPlayerPosition();
    if(!gameLoopRunning){
      gameLoopRunning = true;
      requestAnimationFrame(loop);
    }
  }

  function stopLocalGame(){
    gameLoopRunning = false;
  }

  // update canvas size when shown
  window.addEventListener('resize', ()=>{ if(gameCanvas.style.display !== 'none') resizeGameCanvas(); });

  </script>
</body>
</html>
