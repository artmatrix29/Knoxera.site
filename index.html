<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>2D бродилка — белые стены и кружок игрока</title>
  <style>
    body {
      margin: 0; 
      background: black; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh;
      overflow: hidden;
      user-select: none;
    }
    canvas {
      background: #111;
      display: block;
      border: 2px solid white;
    }
  </style>
</head>
<body>
  <canvas id="game" width="640" height="480"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const tileSize = 40;  // размер клетки
    const map = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
      [1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1],
      [1,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1],
      [1,0,1,0,1,0,0,0,0,1,1,1,0,1,0,1],
      [1,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1],
      [1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1],
      [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ];

    const player = {
      x: tileSize * 1.5,  // позиция в пикселях
      y: tileSize * 1.5,
      radius: tileSize / 3,
      speed: 2.5
    };

    const keys = {
      w: false,
      a: false,
      s: false,
      d: false
    };

    function drawMap() {
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          if (map[y][x] === 1) {
            ctx.fillStyle = 'white';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          }
        }
      }
    }

    function drawPlayer() {
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
    }

    function canMoveTo(x, y) {
      // Проверка столкновения с картой
      // Получаем индексы клетки
      let gridX = Math.floor(x / tileSize);
      let gridY = Math.floor(y / tileSize);

      if (gridY < 0 || gridY >= map.length || gridX < 0 || gridX >= map[0].length) return false;

      return map[gridY][gridX] === 0;
    }

    function update() {
      let nextX = player.x;
      let nextY = player.y;

      if (keys.w) nextY -= player.speed;
      if (keys.s) nextY += player.speed;
      if (keys.a) nextX -= player.speed;
      if (keys.d) nextX += player.speed;

      // Проверяем по точкам вокруг игрока, чтобы не пройти сквозь стену
      if (canMoveTo(nextX + player.radius, player.y)) player.x = nextX;
      if (canMoveTo(nextX - player.radius, player.y)) player.x = nextX;
      if (canMoveTo(player.x, nextY + player.radius)) player.y = nextY;
      if (canMoveTo(player.x, nextY - player.radius)) player.y = nextY;
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawMap();
      drawPlayer();
      update();

      requestAnimationFrame(loop);
    }

    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() in keys) {
        keys[e.key.toLowerCase()] = true;
      }
    });

    window.addEventListener('keyup', e => {
      if (e.key.toLowerCase() in keys) {
        keys[e.key.toLowerCase()] = false;
      }
    });

    loop();
  </script>
</body>
</html>
