<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Knoxera</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: black;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      background: black;
      display: block;
    }
  </style>
</head>
<body>
<canvas id="game" width="640" height="480"></canvas>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const tileSize = 40;
  const chunkSize = 8; 
  const viewChunksRadius = 2;

  const player = {
    x: tileSize * 1.5,
    y: tileSize * 1.5,
    radius: tileSize / 3,
    speed: 2.5
  };

  const keys = { w:false, a:false, s:false, d:false };

  const loadedChunks = {};

  // Генерация чанка с минимум одним выходом на каждой стороне
  function generateChunk(cx, cy) {
    let chunk = [];
    for (let y = 0; y < chunkSize; y++) {
      let row = [];
      for (let x = 0; x < chunkSize; x++) {
        // стены по границе
        if (x === 0 || y === 0 || x === chunkSize - 1 || y === chunkSize - 1) {
          row.push(1);
        } else {
          row.push(Math.random() < 0.1 ? 1 : 0);
        }
      }
      chunk.push(row);
    }

    // Сделаем выходы (открытия) на границах чанка:
    // для связности с соседними чанками на всех 4 сторонах

    // Выход слева (x=0), случайный y между 1 и chunkSize-2
    const exitLeftY = Math.floor(Math.random() * (chunkSize - 2)) + 1;
    chunk[exitLeftY][0] = 0;

    // Выход справа (x=chunkSize-1)
    const exitRightY = Math.floor(Math.random() * (chunkSize - 2)) + 1;
    chunk[exitRightY][chunkSize - 1] = 0;

    // Выход сверху (y=0)
    const exitTopX = Math.floor(Math.random() * (chunkSize - 2)) + 1;
    chunk[0][exitTopX] = 0;

    // Выход снизу (y=chunkSize-1)
    const exitBottomX = Math.floor(Math.random() * (chunkSize - 2)) + 1;
    chunk[chunkSize - 1][exitBottomX] = 0;

    return chunk;
  }

  function getChunkKey(cx, cy) {
    return `${cx},${cy}`;
  }

  function loadChunksAroundPlayer() {
    let playerChunkX = Math.floor(player.x / (tileSize * chunkSize));
    let playerChunkY = Math.floor(player.y / (tileSize * chunkSize));

    for (let cy = playerChunkY - viewChunksRadius; cy <= playerChunkY + viewChunksRadius; cy++) {
      for (let cx = playerChunkX - viewChunksRadius; cx <= playerChunkX + viewChunksRadius; cx++) {
        let key = getChunkKey(cx, cy);
        if (!loadedChunks[key]) {
          loadedChunks[key] = generateChunk(cx, cy);
        }
      }
    }
  }

  function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
    const nearestX = Math.max(rx, Math.min(cx, rx + rw));
    const nearestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return (dx * dx + dy * dy) < (radius * radius);
  }

  function canMoveTo(x, y) {
    for (const key in loadedChunks) {
      let [cx, cy] = key.split(',').map(Number);
      let chunk = loadedChunks[key];

      for (let yy = 0; yy < chunkSize; yy++) {
        for (let xx = 0; xx < chunkSize; xx++) {
          if (chunk[yy][xx] === 1) {
            let wallX = (cx * chunkSize + xx) * tileSize;
            let wallY = (cy * chunkSize + yy) * tileSize;
            if (circleRectCollision(x, y, player.radius, wallX, wallY, tileSize, tileSize)) {
              return false;
            }
          }
        }
      }
    }
    return true;
  }

  // Рисуем только линии (рамки) без заливки
  function drawChunks() {
    const camX = player.x - canvas.width / 2;
    const camY = player.y - canvas.height / 2;

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;

    for (const key in loadedChunks) {
      let [cx, cy] = key.split(',').map(Number);
      let chunk = loadedChunks[key];

      for (let y = 0; y < chunkSize; y++) {
        for (let x = 0; x < chunkSize; x++) {
          if (chunk[y][x] === 1) {
            const px = (cx * chunkSize + x) * tileSize - camX;
            const py = (cy * chunkSize + y) * tileSize - camY;

            ctx.strokeRect(px, py, tileSize, tileSize);
          }
        }
      }
    }
  }

  function drawPlayer() {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    ctx.fillStyle = '#4cc9f0';
    ctx.beginPath();
    ctx.arc(centerX, centerY, player.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function update() {
    let nextX = player.x;
    let nextY = player.y;

    if (keys.w) nextY -= player.speed;
    if (keys.s) nextY += player.speed;
    if (keys.a) nextX -= player.speed;
    if (keys.d) nextX += player.speed;

    if (canMoveTo(nextX, player.y)) player.x = nextX;
    if (canMoveTo(player.x, nextY)) player.y = nextY;

    loadChunksAroundPlayer();
  }

  function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawChunks();
    drawPlayer();
    update();
    requestAnimationFrame(loop);
  }

  window.addEventListener('keydown', e => {
    if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
  });

  window.addEventListener('keyup', e => {
    if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false;
  });

  loadChunksAroundPlayer();
  loop();
</script>
</body>
</html>
