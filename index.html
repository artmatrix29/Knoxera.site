<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Игра с регистрацией</title>
<style>
  body, html {
    margin:0; padding:0; height:100%; background: #222; color: white; font-family: sans-serif;
    overflow: hidden;
  }
  #menu {
    display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh;
  }
  #menu input {
    margin: 5px; padding: 8px; font-size: 16px; width: 200px;
  }
  #menu button {
    margin: 10px; padding: 10px 20px; font-size: 16px;
    cursor: pointer;
  }
  #header {
    display: none; background: #333; padding: 10px; font-size: 20px;
    user-select: none;
  }
  #counter {
    display: none; position: fixed; top: 10px; right: 10px; background: #444; padding: 5px 10px; border-radius: 5px;
    font-size: 18px;
  }
  #controls {
    display: none; position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
    color: white; font-size: 14px; background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 8px;
  }
  canvas#game {
    display: none; background: #111; position: fixed; top: 40px; left: 0; width: 100%; height: calc(100% - 40px);
  }
</style>
</head>
<body>

<div id="menu">
  <input id="nickname" type="text" placeholder="Никнейм" />
  <input id="password" type="password" placeholder="Пароль" />
  <div>
    <button id="register-btn">Регистрация</button>
    <button id="login-btn">Войти</button>
  </div>
  <div id="notice" style="color: #f88; margin-top: 10px;"></div>
</div>

<div id="header"></div>
<div id="counter">Кристаллы: <span id="crystal-count">0</span></div>
<div id="controls">Управление: W A S D — движение, двойной клик по хедеру — выход</div>

<canvas id="game"></canvas>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  // === supabase init ===
  const supabaseUrl = 'https://nkhshvlixjqbeyouapnd.supabase.co';
  const supabaseKey = 'sb_publishable_H9wczHVQq_YvP4v6xtAT_w_0-XDNwha';
  const supabase = supabase.createClient(supabaseUrl, supabaseKey);

  // === UI elements ===
  const menuEl = document.getElementById('menu');
  const header = document.getElementById('header');
  const counterEl = document.getElementById('counter');
  const counterNumber = document.getElementById('crystal-count');
  const controlsEl = document.getElementById('controls');
  const noticeEl = document.getElementById('notice');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // === game constants & variables ===
  const tileSize = 40;
  const chunkSize = 16;
  const chunks = new Map();
  const crystals = new Map(); // key "cx,cy" -> {x,y}
  const player = { x:0, y:0, radius: tileSize/3, speed: 3, color: '#4cc9f0' };
  let crystalsCollected = 0;
  const keys = { w:false, a:false, s:false, d:false };
  let collectedSet = new Set();
  let currentUser = null; // {id, nickname}

  let gameRunning = false;

  // === Helpers: session save/load ===
  function saveSession(user) {
    localStorage.setItem('session', JSON.stringify({ id: user.id, nickname: user.nickname }));
  }
  function loadSession() {
    const sess = localStorage.getItem('session');
    if (!sess) return null;
    try { return JSON.parse(sess); } catch { return null; }
  }
  function clearSession() {
    localStorage.removeItem('session');
  }

  // === Registration & Login ===
  async function registerUser(nickname, password) {
    noticeEl.textContent = '';
    if (!nickname || !password) { noticeEl.textContent = 'Заполните оба поля!'; return null; }
    // Проверим, что ник не занят
    let { data: existing, error: errCheck } = await supabase.from('users').select('id').eq('nickname', nickname).single();
    if (existing) {
      noticeEl.textContent = 'Никнейм занят.';
      return null;
    }
    const { data, error } = await supabase.from('users').insert([{ nickname, password, collected: [], crystals: 0 }]).select().single();
    if (error) {
      noticeEl.textContent = 'Ошибка регистрации: ' + error.message;
      return null;
    }
    return data;
  }

  async function loginUser(nickname, password) {
    noticeEl.textContent = '';
    if (!nickname || !password) { noticeEl.textContent = 'Заполните оба поля!'; return null; }
    const { data, error } = await supabase.from('users').select('*').eq('nickname', nickname).eq('password', password).single();
    if (error || !data) {
      noticeEl.textContent = 'Неверный никнейм или пароль.';
      return null;
    }
    return data;
  }

  document.getElementById('register-btn').addEventListener('click', async () => {
    const nick = document.getElementById('nickname').value.trim();
    const pass = document.getElementById('password').value.trim();
    const user = await registerUser(nick, pass);
    if (user) {
      saveSession(user);
      await enterGame(user);
    }
  });

  document.getElementById('login-btn').addEventListener('click', async () => {
    const nick = document.getElementById('nickname').value.trim();
    const pass = document.getElementById('password').value.trim();
    const user = await loginUser(nick, pass);
    if (user) {
      saveSession(user);
      await enterGame(user);
    }
  });

  // === Game logic functions (from твоего кода) ===

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - header.offsetHeight - 20;
  }
  window.addEventListener('resize', () => { resizeCanvas(); if(gameRunning) draw(); });
  resizeCanvas();

  function generateChunk(cx, cy) {
    let chunk = [];
    for (let y = 0; y < chunkSize; y++) {
      let row = [];
      for (let x = 0; x < chunkSize; x++) {
        if (x > 0 && y > 0 && x < chunkSize - 1 && y < chunkSize - 1) row.push(Math.random() < 0.1 ? 1 : 0);
        else row.push(Math.random() < 0.5 ? 1 : 0);
      }
      chunk.push(row);
    }
    if (Math.random() < 0.6) { const exitLeftY = Math.floor(Math.random() * (chunkSize - 2)) + 1; chunk[exitLeftY][0] = 0; }
    if (Math.random() < 0.6) { const exitRightY = Math.floor(Math.random() * (chunkSize - 2)) + 1; chunk[exitRightY][chunkSize - 1] = 0; }
    if (Math.random() < 0.6) { const exitTopX = Math.floor(Math.random() * (chunkSize - 2)) + 1; chunk[0][exitTopX] = 0; }
    if (Math.random() < 0.6) { const exitBottomX = Math.floor(Math.random() * (chunkSize - 2)) + 1; chunk[chunkSize - 1][exitBottomX] = 0; }

    if (Math.random() < 0.15) {
      let freeCells = [];
      for (let y = 1; y < chunkSize - 1; y++) for (let x = 1; x < chunkSize - 1; x++) if (chunk[y][x] === 0) freeCells.push({ x,y });
      if (freeCells.length) {
        const chosen = freeCells[Math.floor(Math.random() * freeCells.length)];
        const key = `${cx},${cy}`;
        if (!collectedSet.has(key)) {
          const crystalX = cx * chunkSize * tileSize + chosen.x * tileSize + tileSize/2;
          const crystalY = cy * chunkSize * tileSize + chosen.y * tileSize + tileSize/2;
          crystals.set(key, { x: crystalX, y: crystalY });
        }
      }
    }
    return chunk;
  }

  function getChunk(cx, cy) {
    const key = `${cx},${cy}`;
    if (!chunks.has(key)) {
      chunks.set(key, generateChunk(cx, cy));
    }
    return chunks.get(key);
  }

  function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
    const nearestX = Math.max(rx, Math.min(cx, rx + rw));
    const nearestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - nearestX, dy = cy - nearestY;
    return (dx*dx + dy*dy) < (radius*radius);
  }

  function canMoveTo(x, y) {
    const playerRadius = player.radius;
    const cx = Math.floor(x / (tileSize * chunkSize));
    const cy = Math.floor(y / (tileSize * chunkSize));

    for (let ny = cy - 1; ny <= cy + 1; ny++) {
      for (let nx = cx - 1; nx <= cx + 1; nx++) {
        const chunk = getChunk(nx, ny);
        for (let ty = 0; ty < chunkSize; ty++) {
          for (let tx = 0; tx < chunkSize; tx++) {
            if (chunk[ty][tx] === 1) {
              const wallX = nx * chunkSize * tileSize + tx * tileSize;
              const wallY = ny * chunkSize * tileSize + ty * tileSize;
              if (circleRectCollision(x, y, playerRadius, wallX, wallY, tileSize, tileSize)) return false;
            }
          }
        }
      }
    }
    return true;
  }

  function spawnPlayer() {
    const chunk = getChunk(0,0);
    for (let y = 1; y < chunkSize-1; y++) for (let x =1; x < chunkSize-1; x++) if (chunk[y][x]===0) {
      player.x = x*tileSize + tileSize/2;
      player.y = y*tileSize + tileSize/2;
      return;
    }
    player.x = tileSize * chunkSize / 2;
    player.y = tileSize * chunkSize / 2;
  }

  function drawWalls() {
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    const camX = player.x - canvas.width/2;
    const camY = player.y - canvas.height/2;
    const leftChunk = Math.floor(camX/(tileSize*chunkSize)) - 1;
    const rightChunk = Math.floor((camX + canvas.width)/(tileSize*chunkSize)) + 1;
    const topChunk = Math.floor(camY/(tileSize*chunkSize)) - 1;
    const bottomChunk = Math.floor((camY + canvas.height)/(tileSize*chunkSize)) + 1;

    for (let cy = topChunk; cy <= bottomChunk; cy++) {
      for (let cx = leftChunk; cx <= rightChunk; cx++) {
        const chunk = getChunk(cx, cy);
        for (let y = 0; y < chunkSize; y++) {
          for (let x = 0; x < chunkSize; x++) {
            if (chunk[y][x] === 1) {
              const px = cx * chunkSize * tileSize + x * tileSize - camX;
              const py = cy * chunkSize * tileSize + y * tileSize - camY;
              ctx.strokeRect(px, py, tileSize, tileSize);
            }
          }
        }
      }
    }
  }

  function drawCrystals() {
    const camX = player.x - canvas.width/2;
    const camY = player.y - canvas.height/2;
    ctx.fillStyle = 'cyan';
    crystals.forEach((pos, key) => {
      const dx = pos.x - player.x;
      const dy = pos.y - player.y;
      if (Math.abs(dx) < canvas.width/2 + 20 && Math.abs(dy) < canvas.height/2 + 20) {
        const px = pos.x - camX;
        const py = pos.y - camY;
        ctx.beginPath();
        ctx.arc(px, py, 10, 0, Math.PI*2);
        ctx.fill();
      }
    });
  }

  function drawPlayer() {
    ctx.fillStyle = player.color;
    ctx.beginPath();
    const px = canvas.width/2;
    const py = canvas.height/2;
    ctx.arc(px, py, player.radius, 0, Math.PI*2);
    ctx.fill();
  }

  function update() {
    if (!gameRunning) return;

    let nx = player.x, ny = player.y;
    const speed = player.speed;

    if (keys.w) ny -= speed;
    if (keys.s) ny += speed;
    if (keys.a) nx -= speed;
    if (keys.d) nx += speed;

    if (canMoveTo(nx, ny)) {
      player.x = nx; player.y = ny;
    }

    // Проверка сбора кристаллов
    crystals.forEach((pos, key) => {
      const dx = player.x - pos.x;
      const dy = player.y - pos.y;
      if (dx*dx + dy*dy < (player.radius + 10)*(player.radius + 10)) {
        crystals.delete(key);
        collectedSet.add(key);
        crystalsCollected++;
        counterNumber.textContent = crystalsCollected;
        saveProgress();
      }
    });
  }

  function draw() {
    if (!gameRunning) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawWalls();
    drawCrystals();
    drawPlayer();
  }

  // Обработчики клавиш
  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'w') keys.w = true;
    if (e.key.toLowerCase() === 'a') keys.a = true;
    if (e.key.toLowerCase() === 's') keys.s = true;
    if (e.key.toLowerCase() === 'd') keys.d = true;
  });
  window.addEventListener('keyup', (e) => {
    if (e.key.toLowerCase() === 'w') keys.w = false;
    if (e.key.toLowerCase() === 'a') keys.a = false;
    if (e.key.toLowerCase() === 's') keys.s = false;
    if (e.key.toLowerCase() === 'd') keys.d = false;
  });

  // Сохраняем прогресс (в Supabase)
  async function saveProgress() {
    if (!currentUser) return;
    try {
      await supabase.from('users').update({
        crystals: crystalsCollected,
        collected: Array.from(collectedSet)
      }).eq('id', currentUser.id);
    } catch (e) {
      console.error('Ошибка сохранения прогресса:', e);
    }
  }

  // Загружаем прогресс (из Supabase)
  async function loadProgress(user) {
    try {
      const { data, error } = await supabase.from('users').select('crystals, collected').eq('id', user.id).single();
      if (!error && data) {
        crystalsCollected = data.crystals || 0;
        counterNumber.textContent = crystalsCollected;
        collectedSet = new Set(data.collected || []);
        // Удалим собранные кристаллы из карты
        for (const key of collectedSet) crystals.delete(key);
      }
    } catch (e) {
      console.error('Ошибка загрузки прогресса:', e);
    }
  }

  // Вход в игру
  async function enterGame(user) {
    currentUser = user;
    menuEl.style.display = 'none';
    header.style.display = 'block';
    header.textContent = `Привет, ${user.nickname}! (двойной клик — выйти)`;
    counterEl.style.display = 'block';
    controlsEl.style.display = 'block';
    canvas.style.display = 'block';

    crystals.clear();
    chunks.clear();
    collectedSet.clear();
    crystalsCollected = 0;
    counterNumber.textContent = crystalsCollected;
    spawnPlayer();

    await loadProgress(user);

    gameRunning = true;
    gameLoop();
  }

  // Выход из игры
  function exitGame() {
    gameRunning = false;
    clearSession();
    currentUser = null;
    crystals.clear();
    chunks.clear();
    collectedSet.clear();
    crystalsCollected = 0;

    canvas.style.display = 'none';
    header.style.display = 'none';
    counterEl.style.display = 'none';
    controlsEl.style.display = 'none';
    menuEl.style.display = 'flex';
    noticeEl.textContent = '';
  }

  // Двойной клик по header — выход
  header.addEventListener('dblclick', () => {
    if (confirm('Выйти из игры? Прогресс сохранён автоматически.')) {
      exitGame();
    }
  });

  // Основной цикл игры
  function gameLoop() {
    if (!gameRunning) return;
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  // При загрузке страницы — проверяем сессию и если есть — сразу в игру
  window.addEventListener('load', async () => {
    const sess = loadSession();
    if (sess) {
      // Подтянем полный юзер объект из БД (на всякий случай)
      const { data, error } = await supabase.from('users').select('*').eq('id', sess.id).single();
      if (!error && data) {
        await enterGame(data);
      } else {
        clearSession();
      }
    }
  });
</script>

</body>
</html>
