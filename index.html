<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Knoxera</title>
  <link rel="icon" type="image/png" href="knoxeralogo.png" />
  <meta property="og:title" content="Knoxera" />
  <meta property="og:image" content="https://knoxera.site/knoxeralogo.png" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />

  <style>
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: black;
      overflow: hidden;
      user-select: none;
      font-family: Arial, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #header {
      display: flex;
      align-items: center;
      margin: 10px;
      gap: 10px;
      user-select: none;
    }
    #header img {
      height: 40px;
      width: 40px;
      border-radius: 50%;
    }
    #header h1 {
      margin: 0;
      font-weight: normal;
    }
    canvas {
      background: black;
      display: block;
      border: 1px solid white;
      flex-grow: 1;
      width: 100vw;
      height: calc(100vh - 90px); /* минус шапка и отступ снизу */
      margin-bottom: 20px; /* небольшой отступ снизу */
    }
    #counter {
      position: fixed;
      top: 10px;
      right: 20px;
      font-size: 18px;
      font-weight: bold;
      user-select: none;
      color: #4cc9f0;
      text-shadow: 0 0 5px black;
      z-index: 10;
    }
  </style>
</head>
<body>

  <div id="header">
    <img src="knoxeralogo.png" alt="Knoxera Logo" />
    <h1>Knoxera</h1>
  </div>

  <canvas id="game"></canvas>
  <div id="counter">Кристаллы: 0</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const counter = document.getElementById('counter');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - document.getElementById('header').offsetHeight - 20; // отступ снизу 20px
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const tileSize = 40;
    const chunkSize = 16;

    const chunks = new Map();
    const crystals = new Map();

    const player = {
      x: 0,
      y: 0,
      radius: tileSize / 3,
      speed: 3,
    };

    let crystalsCollected = 0;

    const keys = { w: false, a: false, s: false, d: false };

    function generateChunk(cx, cy) {
      let chunk = [];
      for (let y = 0; y < chunkSize; y++) {
        let row = [];
        for (let x = 0; x < chunkSize; x++) {
          if (x > 0 && y > 0 && x < chunkSize - 1 && y < chunkSize - 1) {
            row.push(Math.random() < 0.1 ? 1 : 0);
          } else {
            row.push(Math.random() < 0.5 ? 1 : 0);
          }
        }
        chunk.push(row);
      }

      // Проходы по краям
      if (Math.random() < 0.6) {
        const exitLeftY = Math.floor(Math.random() * (chunkSize - 2)) + 1;
        chunk[exitLeftY][0] = 0;
      }
      if (Math.random() < 0.6) {
        const exitRightY = Math.floor(Math.random() * (chunkSize - 2)) + 1;
        chunk[exitRightY][chunkSize - 1] = 0;
      }
      if (Math.random() < 0.6) {
        const exitTopX = Math.floor(Math.random() * (chunkSize - 2)) + 1;
        chunk[0][exitTopX] = 0;
      }
      if (Math.random() < 0.6) {
        const exitBottomX = Math.floor(Math.random() * (chunkSize - 2)) + 1;
        chunk[chunkSize - 1][exitBottomX] = 0;
      }

      // Добавляем кристалл с вероятностью 15% в свободной точке
      if (Math.random() < 0.15) {
        let freeCells = [];
        for (let y = 1; y < chunkSize - 1; y++) {
          for (let x = 1; x < chunkSize - 1; x++) {
            if (chunk[y][x] === 0) {
              freeCells.push({ x, y });
            }
          }
        }
        if (freeCells.length > 0) {
          const chosen = freeCells[Math.floor(Math.random() * freeCells.length)];
          const crystalX = cx * chunkSize * tileSize + chosen.x * tileSize + tileSize / 2;
          const crystalY = cy * chunkSize * tileSize + chosen.y * tileSize + tileSize / 2;
          crystals.set(`${cx},${cy}`, { x: crystalX, y: crystalY });
        }
      }

      return chunk;
    }

    function getChunk(cx, cy) {
      const key = `${cx},${cy}`;
      if (!chunks.has(key)) {
        chunks.set(key, generateChunk(cx, cy));
      }
      return chunks.get(key);
    }

    function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
      const nearestX = Math.max(rx, Math.min(cx, rx + rw));
      const nearestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - nearestX;
      const dy = cy - nearestY;
      return (dx * dx + dy * dy) < (radius * radius);
    }

    function canMoveTo(x, y) {
      const playerRadius = player.radius;
      const cx = Math.floor(x / (tileSize * chunkSize));
      const cy = Math.floor(y / (tileSize * chunkSize));

      for (let ny = cy - 1; ny <= cy + 1; ny++) {
        for (let nx = cx - 1; nx <= cx + 1; nx++) {
          const chunk = getChunk(nx, ny);
          for (let ty = 0; ty < chunkSize; ty++) {
            for (let tx = 0; tx < chunkSize; tx++) {
              if (chunk[ty][tx] === 1) {
                const wallX = nx * chunkSize * tileSize + tx * tileSize;
                const wallY = ny * chunkSize * tileSize + ty * tileSize;

                if (circleRectCollision(x, y, playerRadius, wallX, wallY, tileSize, tileSize)) {
                  return false;
                }
              }
            }
          }
        }
      }
      return true;
    }

    // Спавн игрока в свободном месте (исключая стены)
    function spawnPlayer() {
      const chunk = getChunk(0, 0);
      for (let y = 1; y < chunkSize - 1; y++) {
        for (let x = 1; x < chunkSize - 1; x++) {
          if (chunk[y][x] === 0) {
            player.x = x * tileSize + tileSize / 2;
            player.y = y * tileSize + tileSize / 2;
            return;
          }
        }
      }
      player.x = tileSize * chunkSize / 2;
      player.y = tileSize * chunkSize / 2;
    }

    spawnPlayer();

    function drawWalls() {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 3;
      ctx.beginPath();

      const camX = player.x - canvas.width / 2;
      const camY = player.y - canvas.height / 2;

      const leftChunk = Math.floor(camX / (tileSize * chunkSize)) - 1;
      const rightChunk = Math.floor((camX + canvas.width) / (tileSize * chunkSize)) + 1;
      const topChunk = Math.floor(camY / (tileSize * chunkSize)) - 1;
      const bottomChunk = Math.floor((camY + canvas.height) / (tileSize * chunkSize)) + 1;

      for (let cy = topChunk; cy <= bottomChunk; cy++) {
        for (let cx = leftChunk; cx <= rightChunk; cx++) {
          const chunk = getChunk(cx, cy);

          for (let y = 0; y < chunkSize; y++) {
            for (let x = 0; x < chunkSize; x++) {
              if (chunk[y][x] === 1) {
                const px = cx * chunkSize * tileSize + x * tileSize - camX;
                const py = cy * chunkSize * tileSize + y * tileSize - camY;
                ctx.strokeRect(px, py, tileSize, tileSize);
              }
            }
          }
        }
      }
      ctx.closePath();
    }

    const crystalImage = new Image();
    crystalImage.src = 'greencristal.png';

    function drawCrystals() {
      const camX = player.x - canvas.width / 2;
      const camY = player.y - canvas.height / 2;

      for (const [key, pos] of crystals) {
        const px = pos.x - camX;
        const py = pos.y - camY;
        ctx.drawImage(crystalImage, px - tileSize/3, py - tileSize/3, tileSize * 2 / 3, tileSize * 2 / 3);
      }
    }

    function collectCrystal() {
      for (const [key, pos] of crystals) {
        const dx = player.x - pos.x;
        const dy = player.y - pos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < player.radius + tileSize / 3) {
          crystals.delete(key);
          crystalsCollected++;
          counter.textContent = `Кристаллы: ${crystalsCollected}`;
          break;
        }
      }
    }

    function update() {
      let newX = player.x;
      let newY = player.y;
      if (keys.w) newY -= player.speed;
      if (keys.s) newY += player.speed;
      if (keys.a) newX -= player.speed;
      if (keys.d) newX += player.speed;

      if (canMoveTo(newX, newY)) {
        player.x = newX;
        player.y = newY;
      } else if (canMoveTo(player.x, newY)) {
        player.y = newY;
      } else if (canMoveTo(newX, player.y)) {
        player.x = newX;
      }

      collectCrystal();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawWalls();
      drawCrystals();

      // Игрок
      ctx.fillStyle = 'white';
      ctx.beginPath();
      const px = canvas.width / 2;
      const py = canvas.height / 2;
      ctx.arc(px, py, player.radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener('keyup', e => {
      if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false;
    });

    crystalImage.onload = () => {
      gameLoop();
    };
  </script>
</body>
</html>
